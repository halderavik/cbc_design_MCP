# CBC Design Generator MCP Server - Usage Examples

This document provides comprehensive usage examples for the CBC Design Generator MCP Server, covering common use cases, best practices, and advanced scenarios.

## Table of Contents

1. [Quick Start](#quick-start)
2. [Basic Examples](#basic-examples)
3. [Advanced Examples](#advanced-examples)
4. [Industry-Specific Examples](#industry-specific-examples)
5. [Integration Examples](#integration-examples)
6. [Best Practices](#best-practices)

## Quick Start

### 1. Start the Server
```bash
# Start the MCP server
python -m conjoint_mcp.server
```

### 2. Test Health
```bash
# Test server health
echo '{"jsonrpc": "2.0", "id": 1, "method": "health", "params": {}}' | python -m conjoint_mcp.server
```

### 3. Generate Your First Design
```bash
# Generate a simple design
echo '{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "design.generate",
  "params": {
    "method": "random",
    "grid": {
      "attributes": [
        {
          "name": "Color",
          "levels": [{"name": "Red"}, {"name": "Blue"}, {"name": "Green"}]
        },
        {
          "name": "Size",
          "levels": [{"name": "S"}, {"name": "M"}, {"name": "L"}]
        }
      ]
    },
    "options_per_screen": 3,
    "num_screens": 5
  }
}' | python -m conjoint_mcp.server
```

## Basic Examples

### Example 1: Simple Product Design

**Scenario**: Design a study for a new smartphone with brand, storage, and price attributes.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "design.generate",
  "params": {
    "method": "random",
    "grid": {
      "attributes": [
        {
          "name": "Brand",
          "levels": [
            {"name": "TechCorp"},
            {"name": "MobileMax"},
            {"name": "SmartPhone Inc"}
          ]
        },
        {
          "name": "Storage",
          "levels": [
            {"name": "64GB"},
            {"name": "128GB"},
            {"name": "256GB"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$299"},
            {"name": "$499"},
            {"name": "$699"}
          ]
        }
      ]
    },
    "options_per_screen": 3,
    "num_screens": 8
  }
}
```

**Expected Output**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tasks": [
      {
        "task_index": 1,
        "options": [
          {"Brand": "TechCorp", "Storage": "128GB", "Price": "$499"},
          {"Brand": "MobileMax", "Storage": "64GB", "Price": "$299"},
          {"Brand": "SmartPhone Inc", "Storage": "256GB", "Price": "$699"}
        ]
      }
    ],
    "efficiency": 0.75,
    "notes": "Design generated successfully"
  }
}
```

### Example 2: Parameter Optimization

**Scenario**: Optimize study parameters for statistical power.

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "design.optimize",
  "params": {
    "grid": {
      "attributes": [
        {
          "name": "Brand",
          "levels": [
            {"name": "TechCorp"},
            {"name": "MobileMax"},
            {"name": "SmartPhone Inc"}
          ]
        },
        {
          "name": "Storage",
          "levels": [
            {"name": "64GB"},
            {"name": "128GB"},
            {"name": "256GB"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$299"},
            {"name": "$499"},
            {"name": "$699"}
          ]
        }
      ]
    },
    "target_power": 0.8,
    "effect_size": 0.2,
    "alpha": 0.05,
    "max_respondents": 500
  }
}
```

**Expected Output**:
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "num_respondents": 200,
    "num_screens": 12,
    "options_per_screen": 3,
    "expected_power": 0.82,
    "parameter_count": 8,
    "design_complexity": 27,
    "notes": "Optimization completed successfully"
  }
}
```

### Example 3: Design Export

**Scenario**: Export a generated design to CSV format for survey platforms.

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "design.export",
  "params": {
    "design_request": {
      "method": "random",
      "grid": {
        "attributes": [
          {
            "name": "Brand",
            "levels": [
              {"name": "TechCorp"},
              {"name": "MobileMax"}
            ]
          },
          {
            "name": "Price",
            "levels": [
              {"name": "$299"},
              {"name": "$499"}
            ]
          }
        ]
      },
      "options_per_screen": 3,
      "num_screens": 5
    },
    "format": "csv",
    "include_metadata": true
  }
}
```

**Expected Output**:
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": "# CBC Design Export\n# Generated by CBC Design Generator MCP Server\n# Efficiency Score: 0.75\n\nTask_Index,Option_Index,Brand,Price\n1,1,TechCorp,$299\n1,2,MobileMax,$499\n1,3,TechCorp,$499\n2,1,MobileMax,$299\n2,2,TechCorp,$299\n2,3,MobileMax,$499",
    "format": "csv",
    "summary": {
      "total_tasks": 5,
      "total_options": 15,
      "average_options_per_task": 3.0,
      "attributes": ["Brand", "Price"],
      "attribute_levels": {
        "Brand": ["MobileMax", "TechCorp"],
        "Price": ["$299", "$499"]
      },
      "efficiency_score": 0.75,
      "notes": null
    }
  }
}
```

## Advanced Examples

### Example 4: Constrained Design

**Scenario**: Generate a design with prohibited combinations (e.g., luxury items cannot be cheap).

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "design.generate",
  "params": {
    "method": "random",
    "grid": {
      "attributes": [
        {
          "name": "Brand",
          "levels": [
            {"name": "Premium"},
            {"name": "Standard"},
            {"name": "Budget"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$50"},
            {"name": "$100"},
            {"name": "$200"}
          ]
        },
        {
          "name": "Features",
          "levels": [
            {"name": "Basic"},
            {"name": "Advanced"},
            {"name": "Premium"}
          ]
        }
      ]
    },
    "options_per_screen": 3,
    "num_screens": 10,
    "constraints": {
      "prohibited_combinations": [
        {
          "attributes": {"Brand": "Premium", "Price": "$50"},
          "reason": "Premium brand cannot be sold at budget price"
        },
        {
          "attributes": {"Brand": "Budget", "Features": "Premium"},
          "reason": "Budget brand cannot have premium features"
        }
      ]
    }
  }
}
```

### Example 5: D-Optimal Design

**Scenario**: Generate a statistically optimal design for maximum efficiency.

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "method": "design.generate",
  "params": {
    "method": "doptimal",
    "grid": {
      "attributes": [
        {
          "name": "Color",
          "levels": [
            {"name": "Red"},
            {"name": "Blue"},
            {"name": "Green"},
            {"name": "Yellow"}
          ]
        },
        {
          "name": "Size",
          "levels": [
            {"name": "S"},
            {"name": "M"},
            {"name": "L"}
          ]
        },
        {
          "name": "Material",
          "levels": [
            {"name": "Cotton"},
            {"name": "Polyester"},
            {"name": "Wool"}
          ]
        }
      ]
    },
    "options_per_screen": 4,
    "num_screens": 15
  }
}
```

### Example 6: Complex Multi-Attribute Design

**Scenario**: Design a study with many attributes and levels for comprehensive analysis.

```json
{
  "jsonrpc": "2.0",
  "id": 6,
  "method": "design.generate",
  "params": {
    "method": "balanced",
    "grid": {
      "attributes": [
        {
          "name": "Category",
          "levels": [
            {"name": "Premium"},
            {"name": "Standard"},
            {"name": "Budget"}
          ]
        },
        {
          "name": "Feature_A",
          "levels": [
            {"name": "Basic"},
            {"name": "Advanced"},
            {"name": "Professional"}
          ]
        },
        {
          "name": "Feature_B",
          "levels": [
            {"name": "Standard"},
            {"name": "Enhanced"},
            {"name": "Premium"}
          ]
        },
        {
          "name": "Support",
          "levels": [
            {"name": "Email"},
            {"name": "Phone"},
            {"name": "24/7"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$99"},
            {"name": "$199"},
            {"name": "$299"},
            {"name": "$399"}
          ]
        }
      ]
    },
    "options_per_screen": 4,
    "num_screens": 20,
    "constraints": {
      "prohibited_combinations": [
        {
          "attributes": {"Category": "Budget", "Support": "24/7"},
          "reason": "Budget category cannot include 24/7 support"
        }
      ],
      "required_combinations": [
        {
          "attributes": {"Category": "Premium", "Support": "24/7"},
          "reason": "Premium category must include 24/7 support"
        }
      ]
    }
  }
}
```

## Industry-Specific Examples

### Example 7: Food & Beverage

**Scenario**: Design a study for a new energy drink with flavor, size, and price attributes.

```json
{
  "jsonrpc": "2.0",
  "id": 7,
  "method": "design.generate",
  "params": {
    "method": "random",
    "grid": {
      "attributes": [
        {
          "name": "Flavor",
          "levels": [
            {"name": "Original"},
            {"name": "Berry"},
            {"name": "Citrus"},
            {"name": "Tropical"}
          ]
        },
        {
          "name": "Size",
          "levels": [
            {"name": "8oz"},
            {"name": "12oz"},
            {"name": "16oz"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$1.99"},
            {"name": "$2.49"},
            {"name": "$2.99"}
          ]
        },
        {
          "name": "Caffeine",
          "levels": [
            {"name": "Regular"},
            {"name": "Extra"},
            {"name": "Zero"}
          ]
        }
      ]
    },
    "options_per_screen": 3,
    "num_screens": 12
  }
}
```

### Example 8: Travel & Tourism

**Scenario**: Design a study for vacation packages with destination, duration, and accommodation attributes.

```json
{
  "jsonrpc": "2.0",
  "id": 8,
  "method": "design.generate",
  "params": {
    "method": "balanced",
    "grid": {
      "attributes": [
        {
          "name": "Destination",
          "levels": [
            {"name": "Paris"},
            {"name": "Tokyo"},
            {"name": "New York"},
            {"name": "Sydney"},
            {"name": "Dubai"}
          ]
        },
        {
          "name": "Duration",
          "levels": [
            {"name": "3 days"},
            {"name": "5 days"},
            {"name": "7 days"},
            {"name": "10 days"}
          ]
        },
        {
          "name": "Accommodation",
          "levels": [
            {"name": "3-star hotel"},
            {"name": "4-star hotel"},
            {"name": "5-star hotel"},
            {"name": "Luxury resort"}
          ]
        },
        {
          "name": "Price",
          "levels": [
            {"name": "$800"},
            {"name": "$1200"},
            {"name": "$1800"},
            {"name": "$2500"}
          ]
        }
      ]
    },
    "options_per_screen": 3,
    "num_screens": 15,
    "constraints": {
      "prohibited_combinations": [
        {
          "attributes": {"Accommodation": "Luxury resort", "Price": "$800"},
          "reason": "Luxury resort cannot be offered at budget price"
        }
      ]
    }
  }
}
```

### Example 9: Healthcare Services

**Scenario**: Design a study for healthcare service preferences with provider type, appointment time, and cost attributes.

```json
{
  "jsonrpc": "2.0",
  "id": 9,
  "method": "design.generate",
  "params": {
    "method": "orthogonal",
    "grid": {
      "attributes": [
        {
          "name": "Provider_Type",
          "levels": [
            {"name": "General Practitioner"},
            {"name": "Specialist"},
            {"name": "Nurse Practitioner"},
            {"name": "Telemedicine"}
          ]
        },
        {
          "name": "Appointment_Time",
          "levels": [
            {"name": "Same day"},
            {"name": "Next day"},
            {"name": "Within 3 days"},
            {"name": "Within 1 week"}
          ]
        },
        {
          "name": "Location",
          "levels": [
            {"name": "Downtown clinic"},
            {"name": "Suburban office"},
            {"name": "Hospital"},
            {"name": "Virtual visit"}
          ]
        },
        {
          "name": "Cost",
          "levels": [
            {"name": "$50"},
            {"name": "$100"},
            {"name": "$150"},
            {"name": "$200"}
          ]
        }
      ]
    },
    "options_per_screen": 4,
    "num_screens": 12
  }
}
```

## Integration Examples

### Example 10: Python Integration

**Scenario**: Integrate the MCP server into a Python application.

```python
import subprocess
import json

class CBCDesignClient:
    def __init__(self, server_command=None):
        self.server_command = server_command or ["python", "-m", "conjoint_mcp.server"]
    
    def send_request(self, request):
        """Send a JSON-RPC request to the MCP server."""
        line = json.dumps(request) + "\n"
        proc = subprocess.Popen(
            self.server_command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        
        stdout_data, stderr_data = proc.communicate(input=line, timeout=30)
        
        if stdout_data:
            return json.loads(stdout_data.strip().splitlines()[0])
        else:
            raise Exception(f"Server error: {stderr_data}")
    
    def generate_design(self, method, grid, options_per_screen=3, num_screens=10):
        """Generate a CBC design."""
        request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "design.generate",
            "params": {
                "method": method,
                "grid": grid,
                "options_per_screen": options_per_screen,
                "num_screens": num_screens,
            },
        }
        return self.send_request(request)
    
    def optimize_parameters(self, grid, target_power=0.8):
        """Optimize design parameters."""
        request = {
            "jsonrpc": "2.0",
            "id": 2,
            "method": "design.optimize",
            "params": {
                "grid": grid,
                "target_power": target_power,
            },
        }
        return self.send_request(request)
    
    def export_design(self, design_request, format_type="csv"):
        """Export a design."""
        request = {
            "jsonrpc": "2.0",
            "id": 3,
            "method": "design.export",
            "params": {
                "design_request": design_request,
                "format": format_type,
            },
        }
        return self.send_request(request)

# Usage example
client = CBCDesignClient()

# Define a design grid
grid = {
    "attributes": [
        {
            "name": "Color",
            "levels": [{"name": "Red"}, {"name": "Blue"}, {"name": "Green"}]
        },
        {
            "name": "Size",
            "levels": [{"name": "S"}, {"name": "M"}, {"name": "L"}]
        }
    ]
}

# Generate a design
result = client.generate_design("random", grid, options_per_screen=3, num_screens=5)
print(f"Generated {len(result['result']['tasks'])} tasks")

# Optimize parameters
opt_result = client.optimize_parameters(grid)
print(f"Recommended: {opt_result['result']['num_respondents']} respondents")

# Export design
export_result = client.export_design(
    {"method": "random", "grid": grid, "options_per_screen": 3, "num_screens": 5},
    "csv"
)
print(f"Exported {len(export_result['result']['content'])} characters")
```

### Example 11: JavaScript/Node.js Integration

**Scenario**: Integrate the MCP server into a Node.js application.

```javascript
const { spawn } = require('child_process');
const readline = require('readline');

class CBCDesignClient {
    constructor(serverCommand = ['python', '-m', 'conjoint_mcp.server']) {
        this.serverCommand = serverCommand;
    }
    
    async sendRequest(request) {
        return new Promise((resolve, reject) => {
            const proc = spawn(this.serverCommand[0], this.serverCommand.slice(1), {
                stdio: ['pipe', 'pipe', 'pipe']
            });
            
            const line = JSON.stringify(request) + '\n';
            proc.stdin.write(line);
            proc.stdin.end();
            
            let stdout = '';
            proc.stdout.on('data', (data) => {
                stdout += data.toString();
            });
            
            proc.on('close', (code) => {
                if (code === 0) {
                    try {
                        const response = JSON.parse(stdout.trim().split('\n')[0]);
                        resolve(response);
                    } catch (error) {
                        reject(new Error(`Failed to parse response: ${error.message}`));
                    }
                } else {
                    reject(new Error(`Server exited with code ${code}`));
                }
            });
            
            proc.on('error', (error) => {
                reject(error);
            });
        });
    }
    
    async generateDesign(method, grid, optionsPerScreen = 3, numScreens = 10) {
        const request = {
            jsonrpc: "2.0",
            id: 1,
            method: "design.generate",
            params: {
                method: method,
                grid: grid,
                options_per_screen: optionsPerScreen,
                num_screens: numScreens
            }
        };
        return await this.sendRequest(request);
    }
    
    async optimizeParameters(grid, targetPower = 0.8) {
        const request = {
            jsonrpc: "2.0",
            id: 2,
            method: "design.optimize",
            params: {
                grid: grid,
                target_power: targetPower
            }
        };
        return await this.sendRequest(request);
    }
    
    async exportDesign(designRequest, formatType = "csv") {
        const request = {
            jsonrpc: "2.0",
            id: 3,
            method: "design.export",
            params: {
                design_request: designRequest,
                format: formatType
            }
        };
        return await this.sendRequest(request);
    }
}

// Usage example
async function main() {
    const client = new CBCDesignClient();
    
    const grid = {
        attributes: [
            {
                name: "Color",
                levels: [{name: "Red"}, {name: "Blue"}, {name: "Green"}]
            },
            {
                name: "Size",
                levels: [{name: "S"}, {name: "M"}, {name: "L"}]
            }
        ]
    };
    
    try {
        // Generate a design
        const result = await client.generateDesign("random", grid, 3, 5);
        console.log(`Generated ${result.result.tasks.length} tasks`);
        
        // Optimize parameters
        const optResult = await client.optimizeParameters(grid);
        console.log(`Recommended: ${optResult.result.num_respondents} respondents`);
        
        // Export design
        const exportResult = await client.exportDesign(
            {method: "random", grid: grid, options_per_screen: 3, num_screens: 5},
            "csv"
        );
        console.log(`Exported ${exportResult.result.content.length} characters`);
        
    } catch (error) {
        console.error('Error:', error.message);
    }
}

main();
```

## Best Practices

### 1. Design Planning
- **Start with parameter optimization** to determine appropriate sample size
- **Use constraints** to improve design quality and realism
- **Test with small designs** before generating large ones
- **Consider your target audience** when selecting attributes and levels

### 2. Algorithm Selection
- **Random**: Fastest, good for testing and prototyping
- **Balanced**: Good balance of speed and quality for most use cases
- **Orthogonal**: Best for orthogonal designs and statistical efficiency
- **D-Optimal**: Best statistical properties, use for final studies

### 3. Performance Optimization
- **Monitor response times** and adjust design complexity accordingly
- **Use appropriate sample sizes** based on optimization results
- **Export results** for external analysis and storage
- **Cache frequently used designs** to avoid regeneration

### 4. Error Handling
- **Always check for errors** in responses
- **Validate inputs** before sending requests
- **Handle timeouts** gracefully
- **Log errors** for debugging and monitoring

### 5. Integration
- **Use connection pooling** for high-volume applications
- **Implement retry logic** for transient failures
- **Monitor performance metrics** in production
- **Test thoroughly** before deploying to production

### 6. Data Management
- **Save exported designs** for future reference
- **Version control** your design specifications
- **Document your studies** with metadata and notes
- **Backup important designs** regularly

## Troubleshooting

### Common Issues
1. **Server not responding**: Check if the server is running and accessible
2. **Invalid parameters**: Verify your request format and parameter types
3. **Timeout errors**: Reduce design complexity or increase timeout values
4. **Memory errors**: Reduce the number of attributes, levels, or screens
5. **Constraint violations**: Review your constraint specifications

### Debug Tips
1. **Use the interactive tester** for step-by-step debugging
2. **Check server logs** for detailed error information
3. **Test with simple designs** first
4. **Validate your JSON** before sending requests
5. **Use the performance monitor** to identify bottlenecks

For more detailed troubleshooting information, see the [Troubleshooting Guide](troubleshooting.md).
